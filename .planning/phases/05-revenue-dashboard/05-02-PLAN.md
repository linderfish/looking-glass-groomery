---
phase: 05-revenue-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/telegram-bot/src/services/natural-language.ts
  - apps/telegram-bot/src/handlers/voice.ts
autonomous: true

must_haves:
  truths:
    - "Kimmie asks 'how much did I make today' and sees today's revenue"
    - "Kimmie asks 'weekly revenue' and sees week-to-date revenue"
    - "Kimmie asks 'monthly revenue' and sees progress toward goal"
    - "Kimmie can check YTD revenue via voice or text"
    - "Revenue queries work via voice messages (same as text)"
  artifacts:
    - path: "apps/telegram-bot/src/services/natural-language.ts"
      provides: "Revenue query pattern detection and processing"
      contains: "revenuePatterns"
    - path: "apps/telegram-bot/src/handlers/voice.ts"
      provides: "Revenue result rendering in voice handler"
      contains: "case 'revenue'"
  key_links:
    - from: "apps/telegram-bot/src/services/natural-language.ts"
      to: "apps/telegram-bot/src/services/stripe.ts"
      via: "Import and call revenue functions"
      pattern: "import.*from.*\\.\\./services/stripe"
    - from: "apps/telegram-bot/src/handlers/voice.ts"
      to: "Natural language result"
      via: "Switch case for revenue type"
      pattern: "case 'revenue'"
---

<objective>
Extend natural language processing to detect and respond to revenue queries in Telegram.

Purpose: Enable Kimmie to ask revenue questions via text or voice ("how much did I make today?") and receive formatted revenue responses. This is the primary requirement - Telegram-first interaction.

Output: Extended natural-language.ts with revenue patterns, updated voice.ts with revenue result handling.
</objective>

<execution_context>
@/home/bitvise/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitvise/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-revenue-dashboard/05-01-SUMMARY.md

Existing files to modify:
@apps/telegram-bot/src/services/natural-language.ts - Currently handles client lookup patterns
@apps/telegram-bot/src/handlers/voice.ts - Currently handles client/clients/not_found result types

Key decision from STATE.md: Natural language handler registered AFTER commands, calls next() for non-matches.

Key decision from 05-RESEARCH.md: Revenue patterns go AFTER client lookup patterns to avoid collisions (e.g., "show me Sarah" should match client, not revenue).

MONTHLY_REVENUE_GOAL env var for goal amount (default 9000).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend NLQueryResult type and add revenue patterns to natural-language.ts</name>
  <files>apps/telegram-bot/src/services/natural-language.ts</files>
  <action>
Modify apps/telegram-bot/src/services/natural-language.ts:

1. Add imports at top:
```typescript
import { getTodayRevenue, getWeekRevenue, getMonthRevenue, getYearRevenue } from './stripe';
import { formatRevenueResponse } from './revenue';
```

2. Extend NLQueryResult union type to include revenue:
```typescript
| {
    type: 'revenue';
    data: string;  // Pre-formatted revenue message
    message: string;
  }
```

3. Add revenue patterns array AFTER the existing client patterns section but BEFORE the final "not recognized" return:
```typescript
const revenuePatterns = [
  { regex: /how much (?:did|have) (?:I|we) (?:make|made|earn|earned) today/i, period: 'today' as const },
  { regex: /(?:what's|whats|what is) (?:my|our|the) revenue (?:for )?today/i, period: 'today' as const },
  { regex: /today'?s revenue/i, period: 'today' as const },
  { regex: /how much (?:did|have) (?:I|we) (?:make|made|earn|earned) this week/i, period: 'week' as const },
  { regex: /(?:what's|whats|what is) (?:my|our|the) (?:weekly|week'?s) revenue/i, period: 'week' as const },
  { regex: /this week'?s revenue/i, period: 'week' as const },
  { regex: /how much (?:did|have) (?:I|we) (?:make|made|earn|earned) this month/i, period: 'month' as const },
  { regex: /(?:what's|whats|what is) (?:my|our|the) (?:monthly|month'?s) revenue/i, period: 'month' as const },
  { regex: /this month'?s revenue/i, period: 'month' as const },
  { regex: /(?:year to date|ytd|yearly) revenue/i, period: 'year' as const },
  { regex: /how much (?:did|have) (?:I|we) (?:make|made|earn|earned) (?:this|the) year/i, period: 'year' as const },
];
```

4. Add revenue pattern matching loop AFTER the existing client pattern loop (after the `for (const pattern of patterns)` block), BEFORE the final "not recognized" return:
```typescript
// Revenue query detection (AFTER client patterns to avoid collisions)
for (const pattern of revenuePatterns) {
  if (pattern.regex.test(text)) {
    try {
      let revenue: number;
      let goal: number | undefined;

      switch (pattern.period) {
        case 'today':
          revenue = await getTodayRevenue();
          break;
        case 'week':
          revenue = await getWeekRevenue();
          break;
        case 'month':
          revenue = await getMonthRevenue();
          goal = parseFloat(process.env.MONTHLY_REVENUE_GOAL || '9000');
          break;
        case 'year':
          revenue = await getYearRevenue();
          break;
      }

      const message = formatRevenueResponse(pattern.period, revenue, goal);

      return {
        type: 'revenue',
        data: message,
        message: 'Revenue calculated',
      };
    } catch (error) {
      console.error('Revenue calculation error:', error);
      return {
        type: 'not_found',
        data: null,
        message: "Couldn't calculate revenue - check Stripe connection",
      };
    }
  }
}
```
  </action>
  <verify>TypeScript compiles: cd apps/telegram-bot && npx tsc --noEmit</verify>
  <done>natural-language.ts has revenue patterns and returns type: 'revenue' result with formatted message</done>
</task>

<task type="auto">
  <name>Task 2: Add revenue case to voice handler</name>
  <files>apps/telegram-bot/src/handlers/voice.ts</files>
  <action>
Modify apps/telegram-bot/src/handlers/voice.ts:

1. Add 'revenue' case to the switch statement that handles NL query results:
```typescript
switch (result.type) {
  case 'client':
    await ctx.reply(formatClientProfile(result.data), { parse_mode: 'HTML' });
    break;
  case 'clients':
    await ctx.reply(formatClientList(result.data), { parse_mode: 'HTML' });
    break;
  case 'revenue':
    // Revenue message is pre-formatted with emojis and progress bar
    await ctx.reply(result.data);
    break;
  case 'not_found':
    await ctx.reply(result.message);
    break;
}
```

Note: No parse_mode needed for revenue - the formatted message uses plain text with Unicode emojis and block characters.
  </action>
  <verify>TypeScript compiles: cd apps/telegram-bot && npx tsc --noEmit</verify>
  <done>voice.ts handles revenue result type by displaying the pre-formatted message</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd apps/telegram-bot && npx tsc --noEmit` passes
2. natural-language.ts imports stripe and revenue services
3. NLQueryResult type includes revenue option
4. Revenue patterns added after client patterns in processNaturalLanguageQuery
5. voice.ts has case 'revenue' in switch statement
</verification>

<success_criteria>
1. Query "how much did I make today" returns type: 'revenue' with formatted message
2. Query "monthly revenue" returns progress bar toward goal
3. Voice handler displays revenue results without errors
4. Client queries still work (no pattern collision)
</success_criteria>

<output>
After completion, create `.planning/phases/05-revenue-dashboard/05-02-SUMMARY.md`
</output>
