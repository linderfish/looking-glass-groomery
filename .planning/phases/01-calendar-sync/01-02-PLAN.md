---
phase: 01-calendar-sync
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/cheshire/src/services/booking.ts
  - apps/cheshire/src/routes/appointment.ts
autonomous: true

must_haves:
  truths:
    - "When a booking is confirmed, the calendarEventId is stored on the Appointment record"
    - "When an appointment is rescheduled, the Google Calendar event moves to the new time"
    - "When an appointment is cancelled, the Google Calendar event is deleted"
  artifacts:
    - path: "apps/cheshire/src/services/booking.ts"
      provides: "Store calendarEventId after calendar event creation"
      contains: "calendarEventId"
    - path: "apps/cheshire/src/routes/appointment.ts"
      provides: "Reschedule and cancel endpoints with calendar sync"
      exports: ["rescheduleAppointment", "cancelAppointment"]
  key_links:
    - from: "apps/cheshire/src/services/booking.ts"
      to: "prisma.appointment.update"
      via: "store calendarEventId after createCalendarEvent"
      pattern: "calendarEventId.*eventId"
    - from: "apps/cheshire/src/routes/appointment.ts"
      to: "updateCalendarEvent"
      via: "import from calendar-oauth"
      pattern: "updateCalendarEvent.*calendarEventId"
    - from: "apps/cheshire/src/routes/appointment.ts"
      to: "deleteCalendarEvent"
      via: "import from calendar-oauth"
      pattern: "deleteCalendarEvent.*calendarEventId"
---

<objective>
Wire calendar event ID storage on booking creation and add reschedule/cancel handlers that sync to Google Calendar.

Purpose: Complete the calendar sync lifecycle so Kimmie's Google Calendar accurately reflects appointment changes.
Output: booking.ts stores calendarEventId, new appointment routes handle reschedule and cancel with calendar sync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-calendar-sync/01-RESEARCH.md
@.planning/phases/01-calendar-sync/01-01-SUMMARY.md
@apps/cheshire/src/services/booking.ts
@apps/cheshire/src/services/calendar-oauth.ts
@apps/cheshire/src/routes/
@packages/db/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store calendarEventId after booking creation</name>
  <files>apps/cheshire/src/services/booking.ts</files>
  <action>
Modify the `createBookingInDatabase` function in booking.ts to store the calendarEventId on the Appointment record after creating the calendar event.

Current code (around line 662-675):
```typescript
// Create Google Calendar event
try {
  const clientName = `${client.firstName} ${client.lastName}`.trim()
  const serviceList = state.services || ['Full Groom']
  const calendarEventId = await createCalendarEvent({
    summary: `...`,
    description: `...`,
    start: scheduledAt,
    end: endTime,
  })
  console.log(`[Booking] Created calendar event: ${calendarEventId}`)
} catch (err) {
  console.error('[Booking] Failed to create calendar event:', err)
  // Don't fail the booking if calendar creation fails
}
```

Replace with (stores the event ID in database):
```typescript
// Create Google Calendar event and store the event ID
try {
  const clientName = `${client.firstName} ${client.lastName}`.trim()
  const serviceList = state.services || ['Full Groom']
  const calendarEventId = await createCalendarEvent({
    summary: `üêæ ${pet.name} - ${serviceList.join(', ')}`,
    description: `Client: ${clientName}\nPet: ${pet.name} (${state.petType || 'Dog'})\nServices: ${serviceList.join(', ')}\nBooked via: ${context.channel}\nAppointment ID: ${appointment.id}`,
    start: scheduledAt,
    end: endTime,
  })

  // Store the calendar event ID on the appointment for future updates/deletes
  await prisma.appointment.update({
    where: { id: appointment.id },
    data: { calendarEventId },
  })

  console.log(`[Booking] ‚úÖ Created and linked calendar event: ${calendarEventId}`)
} catch (err) {
  console.error('[Booking] ‚ùå Failed to create/link calendar event:', err)
  // Don't fail the booking if calendar sync fails - appointment exists in DB
  // A retry mechanism should pick this up later (or manual sync)
}
```

Key changes:
1. After createCalendarEvent succeeds, immediately update the appointment with calendarEventId
2. This happens OUTSIDE the main transaction (transactional outbox pattern)
3. If calendar creation fails, appointment still exists (graceful degradation)
4. If the update to store calendarEventId fails after calendar creation, log error but don't fail
  </action>
  <verify>
1. Run: `grep -A5 "Store the calendar event ID" apps/cheshire/src/services/booking.ts` - should show the prisma.appointment.update call
2. Run: `grep "calendarEventId" apps/cheshire/src/services/booking.ts` - should show at least 2 occurrences (variable + update)
3. Run: `cd apps/cheshire && npm run build` - should compile without errors
  </verify>
  <done>
createBookingInDatabase stores calendarEventId on Appointment record after successful calendar event creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create reschedule appointment handler with calendar sync</name>
  <files>apps/cheshire/src/routes/appointment.ts</files>
  <action>
Create a new route file `apps/cheshire/src/routes/appointment.ts` (or add to existing if it exists) with a reschedule endpoint.

If the file doesn't exist, create it:

```typescript
// apps/cheshire/src/routes/appointment.ts
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'
import { prisma } from '@looking-glass/db'
import { updateCalendarEvent, deleteCalendarEvent } from '../services/calendar-oauth'
import { format } from 'date-fns'

const app = new Hono()

// Schema for reschedule request
const RescheduleSchema = z.object({
  appointmentId: z.string(),
  newScheduledAt: z.string().datetime(), // ISO 8601 datetime
  newDuration: z.number().optional(), // Optional - keep existing if not provided
})

/**
 * POST /appointment/reschedule
 * Reschedules an appointment and updates the Google Calendar event
 */
app.post('/reschedule', zValidator('json', RescheduleSchema), async (c) => {
  const { appointmentId, newScheduledAt, newDuration } = c.req.valid('json')

  try {
    // Get the existing appointment with related data
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: {
        pet: true,
        client: true,
        services: true,
      },
    })

    if (!appointment) {
      return c.json({ error: 'Appointment not found' }, 404)
    }

    if (appointment.status === 'CANCELLED') {
      return c.json({ error: 'Cannot reschedule a cancelled appointment' }, 400)
    }

    const newStart = new Date(newScheduledAt)
    const duration = newDuration || appointment.duration
    const newEnd = new Date(newStart.getTime() + duration * 60000)

    // Update the appointment in database
    const updatedAppointment = await prisma.appointment.update({
      where: { id: appointmentId },
      data: {
        scheduledAt: newStart,
        endTime: newEnd,
        duration,
      },
    })

    // Update Google Calendar if we have a linked event
    if (appointment.calendarEventId) {
      try {
        const serviceNames = appointment.services.map(s => s.name).join(', ') || 'Full Groom'
        const clientName = `${appointment.client.firstName} ${appointment.client.lastName}`.trim()

        await updateCalendarEvent(appointment.calendarEventId, {
          summary: `üêæ ${appointment.pet.name} - ${serviceNames}`,
          description: `Client: ${clientName}\nPet: ${appointment.pet.name}\nServices: ${serviceNames}\nRescheduled: ${format(new Date(), 'PPP')}\nAppointment ID: ${appointment.id}`,
          start: newStart,
          end: newEnd,
        })

        console.log(`[Appointment] ‚úÖ Rescheduled and synced calendar: ${appointmentId}`)
      } catch (calendarError) {
        console.error(`[Appointment] ‚ùå Failed to update calendar event:`, calendarError)
        // Don't fail - appointment is updated in DB even if calendar sync fails
      }
    } else {
      console.log(`[Appointment] ‚ö†Ô∏è Rescheduled but no calendarEventId to sync: ${appointmentId}`)
    }

    return c.json({
      success: true,
      appointment: {
        id: updatedAppointment.id,
        scheduledAt: updatedAppointment.scheduledAt,
        endTime: updatedAppointment.endTime,
        calendarSynced: !!appointment.calendarEventId,
      },
    })
  } catch (error) {
    console.error('[Appointment] Reschedule error:', error)
    return c.json({
      error: error instanceof Error ? error.message : 'Failed to reschedule'
    }, 500)
  }
})

export default app
```

Then register this route in `apps/cheshire/src/index.ts`:
1. Import the route: `import appointmentRoutes from './routes/appointment'`
2. Mount it: `app.route('/appointment', appointmentRoutes)`

Add this after the existing route registrations (around line 30-40 where other routes are mounted).
  </action>
  <verify>
1. File exists: `ls apps/cheshire/src/routes/appointment.ts`
2. Route is registered: `grep "appointment" apps/cheshire/src/index.ts` - should show import and route registration
3. Build succeeds: `cd apps/cheshire && npm run build`
4. Route compiles: `grep -n "reschedule" apps/cheshire/src/routes/appointment.ts` - should show the endpoint
  </verify>
  <done>
POST /appointment/reschedule endpoint exists, updates appointment in database, and syncs changes to Google Calendar.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add cancel appointment handler with calendar sync</name>
  <files>apps/cheshire/src/routes/appointment.ts</files>
  <action>
Add a cancel endpoint to the appointment routes file (apps/cheshire/src/routes/appointment.ts).

Add this endpoint after the reschedule endpoint:

```typescript
// Schema for cancel request
const CancelSchema = z.object({
  appointmentId: z.string(),
  reason: z.string().optional(),
})

/**
 * POST /appointment/cancel
 * Cancels an appointment and deletes the Google Calendar event
 */
app.post('/cancel', zValidator('json', CancelSchema), async (c) => {
  const { appointmentId, reason } = c.req.valid('json')

  try {
    // Get the existing appointment
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      select: {
        id: true,
        status: true,
        calendarEventId: true,
        pet: { select: { name: true } },
      },
    })

    if (!appointment) {
      return c.json({ error: 'Appointment not found' }, 404)
    }

    if (appointment.status === 'CANCELLED') {
      return c.json({ error: 'Appointment is already cancelled' }, 400)
    }

    if (appointment.status === 'COMPLETED') {
      return c.json({ error: 'Cannot cancel a completed appointment' }, 400)
    }

    // Update appointment status to CANCELLED
    const cancelledAppointment = await prisma.appointment.update({
      where: { id: appointmentId },
      data: {
        status: 'CANCELLED',
        cancelledAt: new Date(),
        cancelReason: reason,
      },
    })

    // Delete from Google Calendar if we have a linked event
    if (appointment.calendarEventId) {
      try {
        await deleteCalendarEvent(appointment.calendarEventId)
        console.log(`[Appointment] ‚úÖ Cancelled and removed from calendar: ${appointmentId}`)
      } catch (calendarError) {
        console.error(`[Appointment] ‚ùå Failed to delete calendar event:`, calendarError)
        // Don't fail - appointment is cancelled in DB even if calendar sync fails
      }
    } else {
      console.log(`[Appointment] ‚ö†Ô∏è Cancelled but no calendarEventId to remove: ${appointmentId}`)
    }

    return c.json({
      success: true,
      appointment: {
        id: cancelledAppointment.id,
        status: cancelledAppointment.status,
        cancelledAt: cancelledAppointment.cancelledAt,
        calendarDeleted: !!appointment.calendarEventId,
      },
    })
  } catch (error) {
    console.error('[Appointment] Cancel error:', error)
    return c.json({
      error: error instanceof Error ? error.message : 'Failed to cancel'
    }, 500)
  }
})
```

Key implementation details:
- Validates appointment exists and isn't already cancelled/completed
- Updates database status to CANCELLED with timestamp and optional reason
- Deletes calendar event if calendarEventId exists (graceful if sync fails)
- Returns success even if calendar delete fails (transactional outbox pattern)
  </action>
  <verify>
1. Run: `grep -n "cancel" apps/cheshire/src/routes/appointment.ts` - should show the cancel endpoint
2. Run: `grep "deleteCalendarEvent" apps/cheshire/src/routes/appointment.ts` - should show import and usage
3. Run: `cd apps/cheshire && npm run build` - should compile without errors
  </verify>
  <done>
POST /appointment/cancel endpoint exists, marks appointment as CANCELLED in database, and deletes Google Calendar event.
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify the full calendar sync lifecycle:

1. **Creation stores ID:**
   ```bash
   grep -B2 -A5 "Store the calendar event ID" apps/cheshire/src/services/booking.ts
   ```

2. **Reschedule endpoint exists:**
   ```bash
   grep -n "reschedule" apps/cheshire/src/routes/appointment.ts
   ```

3. **Cancel endpoint exists:**
   ```bash
   grep -n "cancel" apps/cheshire/src/routes/appointment.ts
   ```

4. **Calendar API functions imported:**
   ```bash
   grep "updateCalendarEvent\|deleteCalendarEvent" apps/cheshire/src/routes/appointment.ts
   ```

5. **Routes registered in main app:**
   ```bash
   grep "appointment" apps/cheshire/src/index.ts
   ```

6. **Full build succeeds:**
   ```bash
   cd apps/cheshire && npm run build
   ```
</verification>

<success_criteria>
1. booking.ts stores calendarEventId on Appointment after creating calendar event
2. POST /appointment/reschedule endpoint updates appointment and syncs to Google Calendar
3. POST /appointment/cancel endpoint cancels appointment and deletes Google Calendar event
4. Both endpoints handle missing calendarEventId gracefully (don't fail if calendar sync fails)
5. Routes are registered in apps/cheshire/src/index.ts
6. Cheshire app builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-calendar-sync/01-02-SUMMARY.md`
</output>
