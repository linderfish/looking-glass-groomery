---
phase: 02-client-pet-lookup
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - apps/telegram-bot/src/services/formatting.ts
  - apps/telegram-bot/src/handlers/lookup.ts
autonomous: true

must_haves:
  truths:
    - "Kimmie asks for visit history and sees last 5 appointments with services"
    - "Kimmie asks natural language questions like 'who's the lady with the corgi' and gets results"
  artifacts:
    - path: "apps/telegram-bot/src/services/formatting.ts"
      provides: "Visit history formatting"
      exports: ["formatVisitHistory"]
    - path: "apps/telegram-bot/src/handlers/lookup.ts"
      provides: "Visit history callback and natural language handler"
      contains: ["callbackQuery(/^history:/", "callbackQuery(/^pethistory:/", "on('message:text'"]
  key_links:
    - from: "apps/telegram-bot/src/handlers/lookup.ts"
      to: "prisma.appointment"
      via: "findMany with COMPLETED status"
      pattern: "prisma\\.appointment\\.findMany"
    - from: "apps/telegram-bot/src/handlers/lookup.ts natural language handler"
      to: "searchClientsByName"
      via: "regex pattern match then search"
      pattern: "who.*|find.*|lookup.*"
---

<objective>
Add visit history display for clients/pets and natural language query support for conversational lookups.

Purpose: Let Kimmie see appointment history without navigating menus, and ask natural questions like "who's the lady with the corgi" instead of exact commands.

Output: Visit history button shows last 5 appointments; natural language queries work for lookups.
</objective>

<execution_context>
@/home/bitvise/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitvise/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/bitvise/projects/kimmie/.planning/PROJECT.md
@/home/bitvise/projects/kimmie/.planning/ROADMAP.md
@/home/bitvise/projects/kimmie/.planning/STATE.md
@/home/bitvise/projects/kimmie/.planning/phases/02-client-pet-lookup/02-RESEARCH.md

# Prior plan outputs
@/home/bitvise/projects/kimmie/.planning/phases/02-client-pet-lookup/02-01-PLAN.md
@/home/bitvise/projects/kimmie/.planning/phases/02-client-pet-lookup/02-02-PLAN.md

# Schema reference for Appointment model
@/home/bitvise/projects/kimmie/packages/db/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add visit history formatting and callback handlers</name>
  <files>
    apps/telegram-bot/src/services/formatting.ts
    apps/telegram-bot/src/handlers/lookup.ts
  </files>
  <action>
1. Add to `apps/telegram-bot/src/services/formatting.ts`:

   `formatVisitHistory(appointments: (Appointment & { pet: Pet, services: Service[] })[]): string`
   - Format last N completed appointments:
     ```
     <b>Visit History</b>

     1. <b>DATE</b> - PET_NAME
        SERVICES_LIST
        [Notes if any]

     2. <b>DATE</b> - PET_NAME
        ...
     ```
   - Use date-fns format(completedAt, 'MMM d, yyyy')
   - List services as comma-separated names
   - Handle empty list: "No visit history found"

2. Add to `apps/telegram-bot/src/handlers/lookup.ts`:

   Client history callback (`history:clientId`):
   ```typescript
   lookupHandler.callbackQuery(/^history:(.+)$/, async (ctx) => {
     const clientId = ctx.match[1]
     await ctx.answerCallbackQuery()

     const appointments = await prisma.appointment.findMany({
       where: {
         clientId,
         status: 'COMPLETED',
       },
       include: {
         pet: true,
         services: true,
       },
       orderBy: { completedAt: 'desc' },
       take: 5,
     })

     const message = formatVisitHistory(appointments)

     await ctx.reply(message, {
       parse_mode: 'HTML',
       reply_markup: {
         inline_keyboard: [
           [{ text: ' Back to Client', callback_data: `client:${clientId}` }],
         ],
       },
     })
   })
   ```

   Pet history callback (`pethistory:petId`):
   ```typescript
   lookupHandler.callbackQuery(/^pethistory:(.+)$/, async (ctx) => {
     const petId = ctx.match[1]
     await ctx.answerCallbackQuery()

     const appointments = await prisma.appointment.findMany({
       where: {
         petId,
         status: 'COMPLETED',
       },
       include: {
         pet: true,
         services: true,
       },
       orderBy: { completedAt: 'desc' },
       take: 5,
     })

     const pet = await prisma.pet.findUnique({ where: { id: petId } })

     const message = formatVisitHistory(appointments)

     await ctx.reply(message, {
       parse_mode: 'HTML',
       reply_markup: {
         inline_keyboard: [
           [{ text: ' Back to Pet', callback_data: `pet:${petId}` }],
           [{ text: ' Back to Client', callback_data: `client:${pet?.clientId}` }],
         ],
       },
     })
   })
   ```
  </action>
  <verify>
    - TypeScript compiles: `cd apps/telegram-bot && npx tsc --noEmit`
    - In Telegram: From client profile, tap "Visit History" button
    - Visit history shows last 5 completed appointments with services
    - From pet profile, tap "Visit History" shows that pet's history
  </verify>
  <done>
    - formatVisitHistory formats appointment list with dates and services
    - history:clientId callback shows client's visit history
    - pethistory:petId callback shows pet's visit history
    - Back buttons navigate correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add natural language query handler</name>
  <files>
    apps/telegram-bot/src/handlers/lookup.ts
  </files>
  <action>
Add natural language message handler to lookup.ts:

```typescript
// Natural language lookup - must be AFTER command handlers, calls next() for non-matches
lookupHandler.on('message:text', async (ctx, next) => {
  const text = ctx.message.text

  // Skip commands - let other handlers process them
  if (text.startsWith('/')) {
    return next()
  }

  // Phone number detection - digits with optional separators
  const phoneMatch = text.match(/\b(\d{3}[-.\s]?\d{3}[-.\s]?\d{4})\b/)
  if (phoneMatch) {
    const client = await searchClientByPhone(phoneMatch[1])
    if (client) {
      return showClientProfile(ctx, client)
    }
    await ctx.reply(`No client found with phone ${phoneMatch[1]}`)
    return
  }

  // Natural language search patterns
  const patterns = [
    /who(?:'s|'s|\s+is)\s+(?:the\s+)?(.+?)(?:\s+with\s+(?:the\s+)?(.+))?$/i,  // "who's Sarah" or "who's the lady with the corgi"
    /find\s+(.+)/i,                                    // "find Sarah"
    /show\s+(?:me\s+)?(.+)/i,                         // "show me Sarah"
    /lookup\s+(.+)/i,                                  // "lookup Sarah"
    /(?:do\s+we\s+have|is\s+there)\s+(?:a\s+)?(.+)/i, // "do we have a Sarah"
  ]

  for (const pattern of patterns) {
    const match = text.match(pattern)
    if (match) {
      const searchTerm = match[1].trim()
      const petHint = match[2]?.trim()  // "the corgi" from "who's the lady with the corgi"

      // Search clients
      let clients = await searchClientsByName(searchTerm)

      // If pet hint provided and multiple results, filter by pet species/breed
      if (petHint && clients.length > 1) {
        const petLower = petHint.toLowerCase()
        const filtered = clients.filter(client =>
          client.pets.some(pet =>
            pet.name.toLowerCase().includes(petLower) ||
            pet.breed?.toLowerCase().includes(petLower) ||
            pet.species.toLowerCase().includes(petLower)
          )
        )
        if (filtered.length > 0) {
          clients = filtered
        }
      }

      if (clients.length === 0) {
        // Try searching by pet name/breed directly
        const petResults = await prisma.client.findMany({
          where: {
            pets: {
              some: {
                OR: [
                  { name: { contains: searchTerm, mode: 'insensitive' } },
                  { breed: { contains: searchTerm, mode: 'insensitive' } },
                ],
              },
            },
          },
          include: { pets: true },
          take: 5,
        })

        if (petResults.length > 0) {
          return showClientList(ctx, petResults)
        }

        await ctx.reply(`No matches found for "${searchTerm}"`)
        return
      }

      if (clients.length === 1) {
        return showClientProfile(ctx, clients[0])
      }

      return showClientList(ctx, clients)
    }
  }

  // Not a lookup query - pass to next handler
  await next()
})
```

Also add helper functions if not already extracted:
- `showClientProfile(ctx, client)` - Display client with buttons
- `showClientList(ctx, clients)` - Display multiple clients with selection buttons

Ensure this `on('message:text')` handler is registered AFTER the command handlers in the file order (Grammy processes in registration order).
  </action>
  <verify>
    - TypeScript compiles: `cd apps/telegram-bot && npx tsc --noEmit`
    - Bot starts: `cd apps/telegram-bot && timeout 5s npm run dev || true`
    - In Telegram: "who's Sarah" finds clients named Sarah
    - In Telegram: "find 555-1234" finds client by phone
    - In Telegram: "who's the lady with the corgi" finds clients with corgi pets
    - In Telegram: "show me Max" searches for clients or pets named Max
    - Other messages (not matching patterns) pass through to other handlers
  </verify>
  <done>
    - Natural language patterns detected: who's, find, show me, lookup, do we have
    - Phone numbers in messages trigger phone search
    - Pet hints ("with the corgi") filter results by pet breed/species
    - Fallback pet name search when client name not found
    - Non-matching messages pass to next() handler
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Client profile "Visit History" button shows last 5 appointments
2. Pet profile "Visit History" button shows that pet's appointments
3. "who's Sarah" finds clients named Sarah
4. "555-123-4567" or "find 555-1234" finds client by phone
5. "who's the lady with the corgi" finds clients with corgi pets
6. Other chat messages don't get intercepted (help, etc. still work)
</verification>

<success_criteria>
- LOOKUP-07: Visit history shows last 5 appointments with services - Both client and pet history work
- LOOKUP-08: Natural language queries work ("who's the lady with the corgi") - Pattern matching + pet filtering
</success_criteria>

<output>
After completion, create `.planning/phases/02-client-pet-lookup/02-03-SUMMARY.md`
</output>
