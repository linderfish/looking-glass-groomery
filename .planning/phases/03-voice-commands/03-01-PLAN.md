---
phase: 03-voice-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/telegram-bot/package.json
  - apps/telegram-bot/src/bot.ts
  - apps/telegram-bot/src/services/transcription.ts
  - apps/telegram-bot/src/services/natural-language.ts
  - apps/telegram-bot/src/handlers/lookup.ts
autonomous: true

must_haves:
  truths:
    - "Kimmie speaks a question and gets the same answer she would if she typed it"
    - "Voice queries return client/pet profiles just like typed /lookup commands"
    - "Kimmie can work hands-free without touching her phone to search"
  artifacts:
    - path: "apps/telegram-bot/src/services/transcription.ts"
      provides: "Whisper API wrapper for audio transcription"
      exports: ["transcribeAudio"]
    - path: "apps/telegram-bot/src/services/natural-language.ts"
      provides: "Extracted natural language query processing"
      exports: ["processNaturalLanguageQuery", "NLQueryResult"]
  key_links:
    - from: "apps/telegram-bot/src/bot.ts"
      to: "@grammyjs/files"
      via: "hydrateFiles plugin configuration"
      pattern: "hydrateFiles"
    - from: "apps/telegram-bot/src/services/natural-language.ts"
      to: "apps/telegram-bot/src/services/search.ts"
      via: "searchClientByPhone, searchClientsByName imports"
      pattern: "searchClient(ByPhone|sByName)"
    - from: "apps/telegram-bot/src/handlers/lookup.ts"
      to: "apps/telegram-bot/src/services/natural-language.ts"
      via: "processNaturalLanguageQuery import"
      pattern: "processNaturalLanguageQuery"
---

<objective>
Set up voice infrastructure and extract natural language processing logic so voice handler can reuse the same query logic as typed lookups.

Purpose: Hands-free operation is critical - Kimmie's hands are often wet or covered in dog hair during grooming. This plan prepares the foundation (transcription + NL extraction) for voice commands.

Output:
- @grammyjs/files plugin installed and configured
- Transcription service using OpenAI Whisper API
- Natural language query processing extracted from lookup.ts into reusable service
- Lookup handler refactored to use the new service
</objective>

<execution_context>
@/home/bitvise/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitvise/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-commands/03-RESEARCH.md

# Key source files
@apps/telegram-bot/src/bot.ts
@apps/telegram-bot/src/handlers/lookup.ts
@apps/telegram-bot/src/handlers/index.ts
@apps/telegram-bot/src/index.ts
@apps/telegram-bot/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Voice infrastructure setup</name>
  <files>
    apps/telegram-bot/package.json
    apps/telegram-bot/src/bot.ts
    apps/telegram-bot/src/services/transcription.ts
  </files>
  <action>
1. Install @grammyjs/files plugin:
   ```bash
   cd apps/telegram-bot && npm install @grammyjs/files
   ```

2. Configure files plugin in bot.ts:
   - Import `hydrateFiles` from `@grammyjs/files`
   - After creating the bot, add: `_bot.api.config.use(hydrateFiles(_bot.token))`
   - This MUST be done inside getBot() before any handlers are registered

3. Create transcription service at apps/telegram-bot/src/services/transcription.ts:
   - Import OpenAI from 'openai' (use same pattern as @looking-glass/ai)
   - Create transcribeAudio(filePath: string): Promise<string> function
   - Use openai.audio.transcriptions.create with model 'whisper-1'
   - Handle errors gracefully, throw Error('Transcription failed') on failure
   - File is already in OGG format from Telegram - send directly, no conversion needed

Key patterns from research:
```typescript
import OpenAI from 'openai';
import fs from 'fs';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function transcribeAudio(filePath: string): Promise<string> {
  const transcription = await openai.audio.transcriptions.create({
    file: fs.createReadStream(filePath),
    model: 'whisper-1',
  });
  return transcription.text;
}
```
  </action>
  <verify>
- `npm ls @grammyjs/files` shows installed version
- transcription.ts compiles without errors: `cd apps/telegram-bot && npx tsc --noEmit`
- Verify hydrateFiles in bot.ts: `grep "hydrateFiles" apps/telegram-bot/src/bot.ts`
  </verify>
  <done>
- @grammyjs/files is a dependency in package.json
- bot.ts configures hydrateFiles plugin (grep confirms)
- transcription.ts exports transcribeAudio function
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract natural language service from lookup handler</name>
  <files>
    apps/telegram-bot/src/services/natural-language.ts
    apps/telegram-bot/src/handlers/lookup.ts
  </files>
  <action>
1. Create natural-language.ts service with explicit type definition:

```typescript
// Type definition for natural language query results
export type NLQueryResult = {
  type: 'client';
  data: ClientWithPets;
  message: string;
} | {
  type: 'clients';
  data: ClientWithPets[];
  message: string;
} | {
  type: 'not_found';
  data: null;
  message: string;
};

// Where ClientWithPets matches the existing type from search service
type ClientWithPets = {
  id: string;
  firstName: string;
  lastName: string;
  phone: string | null;
  email: string | null;
  pets: { id: string; name: string; species: string; breed: string | null }[];
};
```

2. Extract the query processing logic from lookup.ts lines 219-306:
   - Import searchClientByPhone, searchClientsByName from services/search
   - Import prisma from @looking-glass/db
   - Export `processNaturalLanguageQuery(query: string): Promise<NLQueryResult>`
   - Move phone detection logic (regex: /\b(\d{3}[-.\s]?\d{3}[-.\s]?\d{4})\b/)
   - Move natural language patterns array (who's, find, show me, lookup, do we have)
   - Move pet hint filtering logic
   - Move pet-by-name/breed fallback search
   - Return NLQueryResult with appropriate type and message

3. Refactor lookup.ts 'message:text' handler (lines 219-306):
   - Import processNaturalLanguageQuery, NLQueryResult from services/natural-language
   - Replace inline logic with call to processNaturalLanguageQuery(text)
   - Based on result.type:
     - 'client': call showClientProfile(ctx, result.data)
     - 'clients': call showClientList(ctx, result.data)
     - 'not_found': ctx.reply(result.message)
   - Keep showClientProfile, showClientList, keyboard functions in lookup.ts (they need ctx)
   - Keep "call next() for non-matches" behavior
  </action>
  <verify>
- `cd apps/telegram-bot && npx tsc --noEmit` passes without errors
- natural-language.ts exports NLQueryResult type: `grep "export type NLQueryResult" apps/telegram-bot/src/services/natural-language.ts`
- natural-language.ts exports processNaturalLanguageQuery: `grep "export.*processNaturalLanguageQuery" apps/telegram-bot/src/services/natural-language.ts`
- lookup.ts imports from natural-language: `grep "natural-language" apps/telegram-bot/src/handlers/lookup.ts`
  </verify>
  <done>
- natural-language.ts exports NLQueryResult type definition
- natural-language.ts exports processNaturalLanguageQuery function
- lookup.ts imports and uses processNaturalLanguageQuery (no duplicate logic)
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd apps/telegram-bot && npx tsc --noEmit` passes
2. Dependencies installed: @grammyjs/files in package.json
3. All new files exist and export expected symbols
4. Lookup handler still works with extracted logic
</verification>

<success_criteria>
1. @grammyjs/files plugin is installed and configured in bot.ts
2. transcribeAudio service calls OpenAI Whisper API
3. NLQueryResult type is explicitly defined and exported
4. processNaturalLanguageQuery extracts shared logic from lookup handler
5. Lookup handler still works (uses same NL service)
6. All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-commands/03-01-SUMMARY.md`
</output>
